package main

import (
	"fmt"
	"sync"
	"time"
)

/*
// time.Sleep использовать нельзя. это будет не валидным ответом на собеседовании
// 1
// Что выведет код и почему?
// Как исправить?
//
// Код будет выводить разные значения. Скорее всего 950 - 990. Это происходит из-за гонки данных - 1000 горутин изменяют
// значение одной переменной одновременно.
// Для исправления необходимо добавить mutex - чтобы ограничить одновременный доступ к одной и той же переменной из
// разных горутин. Также необходимо добавить waitGroup - для ожидания завершения выполнения всех горутин в main.
func main() {
	var counter int
	var mu sync.Mutex
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			mu.Lock()
			counter++
			mu.Unlock()

			wg.Done()
		}()
	}
	wg.Wait()

	fmt.Println(counter)
}

// 2
// Что выведет код и почему?
// Как исправить оставив канал небуферезированным?
//
// Будет deadlock, т.к. программа заблокируется на ch <- 1, а горутина считывающая из канала ch еще не будет создана.
// Для исправления deadlock необходимо переставить вызов горутины и запись в канал местами. Для гарантирования вывода
// в функции fmt.Println(<-ch) также необходимо добавить time.Sleep(), т.к. функция fmt.Println(<-ch) сначала разберет
// аргумент, что разблокирует main, а только после будет производить вывод на консоль, который может не успеть
// произойти до завершения main.
func main() {
	ch := make(chan int)
	go func() {
		fmt.Println(<-ch)
	}()
	ch <- 1
	time.Sleep(time.Nanosecond)
}
*/

// 3
// Расскажи подробно что происходит?(спойлер: почему будет panic?)
// Как сделать так, чтобы работало?
// Panic будет из-за конкурентной записи в мапу - разные горутины одновременно пытаюстя записывать значения в одну и ту
// же мапу, тогда как мапа в го не потокобезопасна.
// Для исправления ошибки необходимо либо создать мапу из пакета sync, либо создать mutex.
// Также x := make(map[int]int, 1) нет смысла инициализировать мапу с емкостью 1, если туда будет внесено более 1
// элемента, т.к. это только замедлит ее работа из-за появившейся эвакуации данных, начиная со 2 элемента в мапе.
func main() {
	var x sync.Map
	go func() { x.Store(1, 2) }()
	go func() { x.Store(3, 7) }()
	go func() { x.Store(123, 10) }()
	go func() { x.Store(1, 2) }()
	go func() { x.Store(34, 7) }()
	go func() { x.Store(1432, 10) }()
	go func() { x.Store(1, 2) }()
	go func() { x.Store(100, 7) }()
	go func() { x.Store(34, 10) }()
	go func() { x.Store(1, 2) }()

	time.Sleep(100 * time.Millisecond) //блокируемся на 100 миллисекунд
	val, _ := x.Load(1)
	fmt.Println("x[1] =", val)

	x := make(map[int]int, 1)
	var mu sync.Mutex
	go func() {
		mu.Lock()
		x[3] = 7
		mu.Unlock()
	}()
	go func() {
		mu.Lock()
		x[123] = 10
		mu.Unlock()
	}()
	go func() {
		mu.Lock()
		x[1] = 2
		mu.Unlock()
	}()
	go func() {
		mu.Lock()
		x[34] = 7
		mu.Unlock()
	}()
	go func() {
		mu.Lock()
		x[1432] = 10
		mu.Unlock()
	}()
	go func() {
		mu.Lock()
		x[1] = 2
		mu.Unlock()
	}()
	go func() {
		mu.Lock()
		x[100] = 7
		mu.Unlock()
	}()
	go func() {
		mu.Lock()
		x[34] = 10
		mu.Unlock()
	}()
	go func() {
		mu.Lock()
		x[1] = 2
		mu.Unlock()
	}()

	time.Sleep(100 * time.Millisecond) //блокируемся на 100 миллисекунд
	fmt.Println("x[1] =", x[1])
}
