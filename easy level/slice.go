package main

import "fmt"

// 1
// Какой будет результат выполнения приложения?
//
// {"a", "q", "c"}
func main() {
	a := []string{"a", "b", "c"}
	b := a[1:2]
	b[0] = "q"
	fmt.Println(a)
}

// 2
// Что выведет код и почему?
// /
// Внутри функции fmt.Println(a) выдаст {5, 5, 5, 5, 5, 5} - потому, что слайс с емкостью 5 пересоздастся, т.к. мы
// изменяем его длину функцией append, что аллоцирует новый массив, на который ссылается слайс.
// В функции main fmt.Println(sl) будет {1, 2, 3, 4, 5} - потому, что базовый массив остался прежнем и внутри функции
// mod был создан слайс, ссылающийся на другой массив.
func mod(a []int) {
	a = append(a, 125)
	for i := range a {
		a[i] = 5
	}
	fmt.Println(a)
}
func main() {
	sl := []int{1, 2, 3, 4, 5}
	mod(sl)
	fmt.Println(sl)
}

// 3
// Что выведет код и почему?
//
// Результат будет - {5, 5, 5, 5} из функции mod и {5, 5, 5, 5} из функции main - потому, что функция mod изменит все
// элементы в базовом массиве слайса. Произойдет это потому, что слайс - это внутри указатель на базовый массив и, т.к.
// слайс не аллоцирует память под новый массив внутри функции mod, будут заменены элементы в базовом массиве.
func mod(a []int) {
	for i := range a {
		a[i] = 5
	}
	fmt.Println(a)
}
func main() {
	sl := make([]int, 4, 8)
	sl[0] = 1
	sl[1] = 2
	sl[2] = 3
	sl[3] = 5
	mod(sl)
	fmt.Println(sl)
}
